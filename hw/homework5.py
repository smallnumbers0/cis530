# -*- coding: utf-8 -*-
"""homework5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bYbSgu2GqSH0cSdGx8TvtwAgpN1g-NCK

# Homework 5: Advanced Vector Space Models

## Due Date: Jun 17
## Total Points: 116 points + 8 bonus
- **Overview**: In this assignment, we will examine some advanced uses of vector representations of words. We are going to look at three different problems:

  - Solving word relation problems like analogies using word embeddings.
  - Comparing correlation for human judgments of similarity to the vector similarities
  - Discovering the different senses of a ‘polysemous’ word by clustering together its paraphrases.


- **Delieverables:** This assignment has several deliverables:
  - Code (this notebook) *(Automatic Graded)*
    - Part 1: answers to questions
    - Part 3: 4 different clustering functions
  - Write Up (include in this notebook or a separate **report.pdf**) *(Manually Graded)*
    - Part 2: answers to questions
    - Part 3: F-scores for clustering algorithms & discussions about your models
  - Leaderboard Without K *(Automatic Graded on GradeScope)*
    - `test_nok_output_leaderboard.txt` = Task 3.4 output file
  - Leaderboard With K *(Automatic Graded on GradeScope)*
    - `test_output_leaderboard.txt` = Task 3.2 or 3.3 output file

- **Grading**: We will use the auto-grading system called `PennGrader`. To complete the homework assignment, you should implement anything marked with `#TODO` and run the cell with `#PennGrader` note.


## Recommended Readings
- [Vector Semantics](https://web.stanford.edu/~jurafsky/slp3/6.pdf). Dan Jurafsky and James H. Martin. Speech and Language Processing (3rd edition draft).
- [Efficient Estimation of Word Representations in Vector Space](https://arxiv.org/pdf/1301.3781.pdf?). Tomas Mikolov, Kai Chen, Greg Corrado, Jeffrey Dean. ArXiV 2013.
- [Linguistic Regularities in Continuous Space Word Representations](https://www.aclweb.org/anthology/N13-1090). Tomas Mikolov, Wen-tau Yih, Geoffrey Zweig. NAACL 2013.
- [Discovering Word Senses from Text](https://cs.uwaterloo.ca/~cdimarco/pdf/cs886/Pantel+Lin02.pdf). Patrick Pangel and Dekang Ling. KDD 2002.
- [Linguistic Regularities in Sparse and Explicit Word Representations](https://aclanthology.org/W14-1618.pdf). Patrick Pangel and Dekang Ling. CoNLL 2014.
- [Clustering Paraphrases by Word Sense](https://www.cis.upenn.edu/~ccb/publications/clustering-paraphrases-by-word-sense.pdf). Anne Cocos and Chris Callison-Burch. NAACL 2016.

## To get started, **make a copy** of this colab notebook into your google drive!

## Setup 1: PennGrader Setup [4 points]
"""

# Commented out IPython magic to ensure Python compatibility.
# ## DO NOT CHANGE ANYTHING, JUST RUN
# %%capture
# !pip install penngrader-client

# Commented out IPython magic to ensure Python compatibility.
# %%writefile notebook-config.yaml
# 
# grader_api_url: 'https://23whrwph9h.execute-api.us-east-1.amazonaws.com/default/Grader23'
# grader_api_key: 'flfkE736fA6Z8GxMDJe2q8Kfk8UDqjsG3GVqOFOa'

!cat notebook-config.yaml

from penngrader.grader import *

## TODO - Start
STUDENT_ID = 56803282 # YOUR PENN-ID GOES HERE AS AN INTEGER#
## TODO - End

SECRET = STUDENT_ID
grader = PennGrader('notebook-config.yaml', 'CIS5300_OL_23Su_HW5', STUDENT_ID, SECRET)

# check if the PennGrader is set up correctly
# do not chance this cell, see if you get 4/4!
name_str = 'Jacky Choi'
grader.grade(test_case_id = 'name_test', answer = name_str)

"""## Setup 2: Dataset / Packages
- **Run the following cells without changing anything!**
"""

### This cell might take 3 min to run ###
! echo "Installing Magnitude.... (please wait, can take a while)"
! (curl https://raw.githubusercontent.com/plasticityai/magnitude/master/install-colab.sh | /bin/bash 1>/dev/null 2>/dev/null)
! echo "Done installing Magnitude."

!pip install spacy
!python -m spacy download en_core_web_sm
!python -m spacy download en

!pip uninstall -y annoy
!pip install annoy

!pip install -U lz4==1.0.0
!pip install -U xxhash==1.0.1
!pip install -U fasteners==0.14.1

import spacy

# Check your python version
!python --version

"""If your python version is >= 3.9, run the code cell below before importing from pymaginitude:"""

spacy.load('en_core_web_sm')
import collections
collections.Sequence = collections.abc.Sequence
collections.Mapping = collections.abc.Mapping
collections.MutableMapping = collections.abc.MutableMapping
collections.Iterable = collections.abc.Iterable
collections.MutableSet = collections.abc.MutableSet
collections.Callable = collections.abc.Callable

from pymagnitude import * # if you encounter an error for this line, try re-running it - I know it's silly but it might work

# this might take ~2min to run
!wget http://magnitude.plasticity.ai/word2vec/light/GoogleNews-vectors-negative300.magnitude

# if the above wget command gives you an error, then uncomment the line below and run this cell
!gdown 115ryZ01s_guR1ySc7YLD2kbAm6UpL7VP

# #mount google drive
# from google.colab import drive
# drive.mount('/content/drive')

from itertools import combinations
from prettytable import PrettyTable
from sklearn.cluster import KMeans
import random
import pandas as pd
import numpy as np
import scipy.stats as stats

# !gdown 1luyNlDu0GdH_B3D6rjYLKIGGfz_S3yU5 # GoogleNews-vectors-negative300.filter.magnitude
!gdown 17a4uC7eNrYdtVlW60wshjyDLcFxTtq0y # SimLex-999.txt
!gdown 1h2DHMuubO7OEVxmGQGbvb2Ovj_A6hakC # dev_input.txt
!gdown 1I83_VA_i_UB-9cf9GcEe5oGPoc8-ZmLh # dev_output.txt
!gdown 1CjK3eYkacyxo3gdLbf9IGdk1DFEfAYvM # test_input.txt
!gdown 1sZuq8a2zHJfe6bLjrK3wD2jrZWkQ0-6S # test_nok_input.txt
!gdown 1gK13ZVDMA5XYi8sZY8G1gOIZMdxGTuay # coocvec-500mostfreq-window-3.filter.magnitude

"""# Section 1: Exploring Analogies and Other Word Pair Relationships [4 points]
**Background:** Word2vec is a very cool word embedding method that was developed by [Thomas Mikolov et al](https://aclanthology.org/N13-1090/). One of the noteworthy things about the method is that it can be used to solve word analogy problems like:

***man is to king as woman is to [blank]***

The way that it they take the vectors representing king, man and woman and perform some vector arithmetic to produce a vector that is close to the expected answer:

***king − man + woman ≈ queen***

We can find the nearest vector in the vocabulary by looking for argmax *cos(x, king − man + woman)*. Omar Levy has an explanation of the method in this [Quora post](https://www.quora.com/unanswered/How-does-Mikolovs-word-analogy-for-word-embedding-work-How-can-I-code-such-a-function) and in the [paper](https://aclanthology.org/W14-1618/).

In addition to solving this sort of analogy problem, the same sort of vector arithmetic was used with word2vec embeddings to find relationships between pairs of words like the following:

<img src='https://drive.google.com/uc?id=1_ewkcJ6EQMuIK0SrgBulzK7LFi8kD9nD'>

In the first part of the assigment, you will play around with the [Magnitude](https://github.com/plasticityai/magnitude) library. You will use Magnitude to load a vector model trained using word2vec, and use it to manipulate and analyze the vectors. In order to proceed further, you need to use the Medium Google-word2vec embedding model trained on Google News by using file `GoogleNews-vectors-negative300.magnitude`. Once the file is downloaded use the following Python commands:
"""

# file_path = "/content/GoogleNews-vectors-negative300.filter.magnitude"
file_path = "/content/GoogleNews-vectors-negative300.magnitude"
vectors = Magnitude(file_path)

"""Now you can use vectors to perform queries. For instance, you can query the distance of cat and dog in the following way:"""

print(vectors.distance("cat", "dog")) # should be ~0.69

"""The questions below are designed to familiarize you with the Magnitude word2vec package and get you thinking about what type of semantic information word embeddings can encode. We recommend reading using the [library section](https://github.com/plasticityai/magnitude#using-the-library) to reply to the following set of questions:

- **Problem 1.1:** What is the dimensionality of these word embeddings? Provide an integer answer. [1 point]
"""

#find dimensionality
vectors.dim

# TODO
dimensionality = 300

# PennGrader - DO NOT CHANGE
grader.grade(test_case_id = 'test_q11_dim', answer = dimensionality) # we only check partial data

""" - **Problem 1.2:** What are the top-5 most similar words to `picnic` (not including `picnic` itself)? (Hint: try using `vectors.most_similar`) Please return these as a list of strings named `mostsim`. [1 point]"""

### The first time you run "vectors.most_similar" it will take about 5~10 mins to run
sim = vectors.most_similar('picnic')
sim

# TODO
mostsim = [i[0] for i in sorted(sim, key=lambda x: x[1], reverse=True)[:5]]

# PennGrader - DO NOT CHANGE
# reload_grader()
grader.grade(test_case_id = 'test_q12_picnic', answer = mostsim) # we only check partial data

""" - **Problem 1.3:** According to the word embeddings, which of these words is not like the others? `['tissue', 'papyrus', 'manila', 'newsprint', 'parchment', 'gazette']` [1 point]"""

diff = vectors.doesnt_match(['tissue', 'papyrus', 'manila', 'newsprint', 'parchment', 'gazette'])
diff

# TODO
doesnt_match = "tissue"

# PennGrader - DO NOT CHANGE
# reload_grader()
grader.grade(test_case_id = 'test_q13_does_not_match', answer = doesnt_match) # we only check partial data

""" -  **Problem 1.4:** Solve the following analogy: `leg` is to `jump` as X is to `throw` [1 point]"""

#X = throw, leg = jump
X = vectors.most_similar_cosmul(positive=['leg', 'throw'], negative=['jump'])
X

# TODO
analogy = "forearm"

# PennGrader - DO NOT CHANGE
# reload_grader()
grader.grade(test_case_id = 'test_q14_analogy', answer = analogy)

"""# Section 2: SimLex-999 Dataset Revisited [10 points + 5 Bonus]
Let us revisit [SimLex-999](https://fh295.github.io/simlex.html) dataset from Extra Credit in HW4. We will use `SimLex-999.txt`.

We provided you a script below that:

1. Takes `word1`, `word2`, and `SimLex` columns from the `SimLex-999.txt` dataset,
2. Computes the similarity between `word1` and `word2` using `GoogleNews-vectors-negative300.magnitude` from Part 1
3. Displays correlation for human judgments of similarity to the vector similarities using [Kendall’s Tau](https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient).
"""

# Reference Code - DO NOT CHANGE
vectors = Magnitude("/content/GoogleNews-vectors-negative300.magnitude")
df = pd.read_csv('/content/SimLex-999.txt', sep='\t')[['word1', 'word2', 'SimLex999']]
human_scores = []
vector_scores = []

counter = 0
for word1, word2, score in df.values.tolist():
    human_scores.append(score)
    similarity_score = vectors.similarity(word1, word2)
    vector_scores.append(similarity_score)
    if counter < 5: # only print the first five
        print(f'{word1},{word2},{score},{similarity_score:.4f}')
        counter += 1

print()
correlation, p_value = stats.kendalltau(human_scores, vector_scores)
print(f'Correlation = {correlation}, P Value = {p_value}')

"""In this part of the assignment we would like for you to explore how the Kendall’s Tau correlation changes based on the similarity. You may use the script we provided or create your own script.

**Please respond to the following questions in your report

Note: **5 Extra points** will be awarded for creativity and a more thorough qualitative analysis.)

- **Answer 2.1:** What is the least similar 2 pairs of words based on human judgement scores and vector similarity? Do the pairs match? [3 points]
"""

human_scores_words = []
vector_scores_words = []
for word1, word2, score in df.values.tolist():
    human_scores_words.append((score, word1, word2))
    similarity_score = vectors.similarity(word1, word2)
    vector_scores_words.append((similarity_score, word1, word2))
#use kendall Taus correlation

"""**TODO**: [Least similar pairs]"""

human_scores_words = sorted(human_scores_words)
print(human_scores_words[0])
vector_scores_words = sorted(vector_scores_words)
print(vector_scores_words[0])
#does not match

"""- **Answer 2.2:** What is the most similar 2 pairs of words based on human judgement scores and vector similarity? Do the pairs match? [3 points]

**TODO**: [Most similar pairs]
"""

print(human_scores_words[-1])
print(vector_scores_words[-1])
#does not match

"""- **Answer 2.3:** Provide correlation scores and p values for the following models:
   - (Stanford - GloVe Wikipedia 2014 + Gigaword 5 6B Medium 50D) `glove.6B.50d.magnitude`
   - (Stanford - GloVe Wikipedia 2014 + Gigaword 5 6B Medium 100D)`glove.6B.100d.magnitude`
   - (Stanford - GloVe Wikipedia 2014 + Gigaword 5 6B Medium 200D) `glove.6B.200d.magnitude`
   - (Stanford - GloVe Wikipedia 2014 + Gigaword 5 6B Medium 300D) `glove.6B.300d.magnitude`
   - (Stanford - GloVe Common Crawl Medium 300D) `love.840B.300d.magnitude`

  **How do those correlation value compare to each other?** [4 points]

**TODO**: [Discussion]
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !wget http://magnitude.plasticity.ai/glove/medium/glove.6B.50d.magnitude
# !wget http://magnitude.plasticity.ai/glove/medium/glove.6B.100d.magnitude
# !wget http://magnitude.plasticity.ai/glove/medium/glove.6B.200d.magnitude
# !wget http://magnitude.plasticity.ai/glove/medium/glove.6B.300d.magnitude
# !wget http://magnitude.plasticity.ai/glove/medium/glove.840B.300d.magnitude

# if the above links do not work, please uncomment the below lines and run them

!gdown 1r0ebRDG-_4ALl3PJ7Vko0DkLcMdLPIoL # glove.6B.50d.magnitude
!gdown 1TQ5W7mma_fYKqVL-Dm7_ogwIftyJpXAT # glove.6B.100d.magnitude
!gdown 1LiKprfuwD434FGC-bf8OARMIKCtNIL4Z # glove.6B.200d.magnitude
!gdown 1_p-9y15JvbobeJ37L5v4kXnWMXsfHsD4 # glove.6B.300d.magnitude
!gdown 1zs0Z-m7YbbVbKvqkq-HEIxNYp3e75-7e # glove.840B.300d.magnitude

model = "glove.6B.50d.magnitude"
vectors = Magnitude(model)
human_scores = []
vector_scores = []

for word1, word2, score in df.values.tolist():
    human_scores.append(score)
    similarity_score = vectors.similarity(word1, word2)
    vector_scores.append(similarity_score)

correlation, p_value = stats.kendalltau(human_scores, vector_scores)
print(f'Correlation = {correlation}, P Value = {p_value}')

## YOUR CODE HERE ##
# you can re-use the code from the Reference Code
models = ['glove.6B.50d.magnitude', 'glove.6B.100d.magnitude', 'glove.6B.200d.magnitude', 'glove.6B.300d.magnitude', 'glove.840B.300d.magnitude']
for model in models:
    vectors = Magnitude(model)
    human_scores = []
    vector_scores = []

    for word1, word2, score in df.values.tolist():
        human_scores.append(score)
        similarity_score = vectors.similarity(word1, word2)
        vector_scores.append(similarity_score)

    correlation, p_value = stats.kendalltau(human_scores, vector_scores)
    print(f'Correlation = {correlation}, P Value = {p_value}')

'''How do those correlation value compare to each other? [4 points]
From the correlation values, it seems like the higher the dimension, the better the correlation is with human judgement values.
'''

"""# Section 3: Creating Word Sense Clusters [96 points]
**Background:** Many Natural Language Processing (NLP) tasks require knowing the sense of polysemous words, which are words with multiple meanings. For example, the word bug can mean:

1. A creepy crawly thing
2. An error in your computer code
3. A virus or bacteria that makes you sick
4. A listening device planted by the FBI

In past research my PhD students and I have looked into automatically deriving the different meaning of polysemous words like bug by clustering their paraphrases. We have developed a resource called [the paraphrase database (PPDB)](http://paraphrase.org/) that contains of paraphrases for tens of millions words and phrases. For the target word bug, we have an unordered list of paraphrases including: insect, glitch, beetle, error, microbe, wire, cockroach, malfunction, microphone, mosquito, virus, tracker, pest, informer, snitch, parasite, bacterium, fault, mistake, failure and many others. We used automatic clustering group those into sets like:

<img src='https://drive.google.com/uc?id=1-YbbvZ0qwRKPiHZ1ZWOm62dfCkfu4tLJ'>

The clusters in the image above approximate the different word senses of bug, where the 4 circles are the 4 senses of bug. The input to this problem is all the paraphrases in a single list, and the task is to separate them correctly. As humans, this is pretty intuitive, but computers are not that smart. You will explore the main idea underlying our word sense clustering method: which measure the similarity between each pair of paraphrases for a target word and then group together the paraphrases that are most similar to each other. This affinity matrix gives an example of one of the methods for measuring similarity that we tried in our [paper](https://www.cis.upenn.edu/~ccb/publications/clustering-paraphrases-by-word-sense.pdf):

<img src='https://drive.google.com/uc?id=1v1dBzwoSM3S3Y1wDUwqcVBEZ7GxxKKJ4'>

Here the darkness values give an indication of how similar paraphrases are to each other. For instance in this example similarity between *insect* and *pest* is greater than the similarity between insect and error. You can read more about this task in [these](https://www.cis.upenn.edu/~ccb/publications/clustering-paraphrases-by-word-sense.pdf) [papers](https://cs.uwaterloo.ca/~cdimarco/pdf/cs886/Pantel+Lin02.pdf).

In this assignment, we will use vector representations in order to measure their similarities of pairs of paraphrases. You will play with different vector space representations of words to create clusters of word senses. We expect that you have read Jurafsky and Martin [Chapter 6](https://web.stanford.edu/~jurafsky/slp3/6.pdf). Word vectors, also known as word embeddings, can be thought of simply as points in some high-dimensional space. Remember in geometry class when you learned about the Euclidean plane, and 2-dimensional points in that plane? It’s not hard to understand distance between those points – you can even measure it with a ruler. Then you learned about 3-dimensional points, and how to calculate the distance between these. These 3-dimensional points can be thought of as positions in physical space.

Now, do your best to stop thinking about physical space, and generalize this idea in your mind: you can calculate a distance between 2-dimensional and 3-dimensional points, now imagine a point with `N` dimensions. The dimensions don’t necessarily have meaning in the same way as the X,Y, and Z dimensions in physical space, but we can calculate distances all the same.

This is how we will use word vectors in this assignment: as points in some high-dimensional space, where distances between points are meaningful. The interpretation of distance between word vectors depends entirely on how they were made, but for our purposes, we will consider distance to measure semantic similarity. Word vectors that are close together should have meanings that are similar.

With this framework, we can see how to solve our paraphrase clustering problem.

**The Data:**
The input data to be used for this assignment consists of sets of paraphrases corresponding to one of polysemous target words, e.g.

Target	  | Paraphrase set
----------|------------------
note.v    | comment mark tell observe state notice say remark mention
hot.a     | raging spicy blistering red-hot live

(Here the `.v` following the target `note` indicates the part of speech)

Your objective is to automatically cluster each paraphrase set such that each cluster contains words pertaining to a single sense, or meaning, of the target word. Note that a single word from the paraphrase set might belong to one or more clusters.

**Development Data:** The development data consists of two files:

1. words file (input)
2. clusters file (output)

The words file `dev_input.txt` is formatted such that each line contains one target, its paraphrase set, and the number of ground truth clusters `k`, separated by a `::` symbol. You can use `k` as input to your clustering algorithm.

`target.pos :: k :: paraphrase1 paraphrase2 paraphrase3 ...`

The clusters file `dev_output.txt` contains the ground truth clusters for each target word’s paraphrase set, split over k lines:

```
target.pos :: 1 :: paraphrase2 paraphrase6
target.pos :: 2 :: paraphrase3 paraphrase4 paraphrase5
    .
    .
    .
target.pos :: k :: paraphrase1 paraphrase9
```

**Test data:** For testing Tasks 3.1 – 3.3, you will receive only words file `test_input.txt` containing the test target words, number of ground truth clusters and their paraphrase sets. For testing Task 3.4, you will receive only words file `test_nok_input.txt` containing the test target words and their paraphrases sets. Neither order of senses, nor order of words in a cluster matter.

**Evaluation:** There are many possible ways to evaluate clustering solutions. For this homework we will rely on the paired F-score, which you can read more about in [this paper](https://www.cs.york.ac.uk/semeval2010_WSI/paper/semevaltask14.pdf).

The general idea behind paired F-score is to treat clustering prediction like a classification problem; given a target word and its paraphrase set, we call a *positive instance* any pair of paraphrases that appear together in a ground-truth cluster. Once we predict a clustering solution for the paraphrase set, we similarly generate the set of word pairs such that both words in the pair appear in the same predicted cluster. We can then evaluate our set of predicted pairs against the ground truth pairs using precision, recall, and F-score.

V-Measure is another metric that is used to evaluate clustering solutions, however we will not be using it in this Assignment.

**Tasks:**
Your task is to fill in 4 functions: `cluster_random`, `cluster_with_sparse_representation`, `cluster_with_dense_representation`, `cluster_with_no_k`.

We provided 5 utility functions for you to use:

1. `load_input_file(file_path)` that converts the input data (the words file) into 2 dictionaries. The first dictionary is a mapping between a target word and a list of paraphrases. The second dictionary is a mapping between a target word and a number of clusters for a given target word.

2. `load_output_file(file_path)` that converts the output data (the clusters file) into a dictionary, where a key is a target word and a value is it’s list of list of paraphrases. Each list of paraphrases is a cluster. Remember that Neither order of senses, nor order of words in a cluster matter.

3. `get_paired_f_score(gold_clustering, predicted_clustering)` that calculates paired F-score given a gold and predicted clustering for a target word.

4. `evaluate_clusterings(gold_clusterings, predicted_clusterings)` that calculates paired F-score for all target words present in the data and prints the final F-Score weighted by the number of senses that a target word has.

5. `write_to_output_file(file_path, clusterings)` that writes the result of the clustering for each target word into the output file (clusters file)
Full points will be awarded for each of the tasks if your implementation gets above a certain threshold on the test dataset. Please submit to autograder to see thresholds. Note that thresholds are based on the scores from the previous year and might be lowered depending on the average performance.
"""

# Helper functions, DO NOT MODIFY
def load_input_file(file_path):
    """
    Loads the input file to two dictionaries
    :param file_path: path to an input file
    :return: 2 dictionaries:
    1. Dictionary, where key is a target word and value is a list of paraphrases
    2. Dictionary, where key is a target word and value is a number of clusters
    """
    word_to_paraphrases_dict = {}
    word_to_k_dict = {}

    with open(file_path, 'r') as fin:
        for line in fin:
            target_word, k, paraphrases = line.split(' :: ')
            word_to_k_dict[target_word] = int(k)
            word_to_paraphrases_dict[target_word] = paraphrases.split()

    return word_to_paraphrases_dict, word_to_k_dict

    #Example for word note, one dictionary value is list of paraphrase [currency, comment, mark, tell], 2nd dictionary has k value of 4 as value
    #{'note': [currency, comment]}, {'note': 5}

def load_output_file(file_path):
    """
    :param file_path: path to an output file
    :return: A dictionary, where key is a target word and value is a list of list of paraphrases
    """
    clusterings = {}

    with open(file_path, 'r') as fin:
        for line in fin:
            target_word, _, paraphrases_in_cluster = line.strip().split(' :: ')
            paraphrases_list = paraphrases_in_cluster.strip().split()
            if target_word not in clusterings:
                clusterings[target_word] = []
            clusterings[target_word].append(paraphrases_list)

    return clusterings

        #{ #key is target word
    #    'note': [['comment', 'remark'], ['mark', 'observe', 'state'], ['tell', 'say', 'mention']] each list is predicted cluster
    #}


def get_paired_f_score(gold_clustering, predicted_clustering):
    """
    :param gold_clustering: gold list of list of paraphrases
    :param predicted_clustering: predicted list of list of paraphrases
    :return: Paired F-Score
    """
    gold_pairs = set()
    for gold_cluster in gold_clustering:
        for pair in combinations(gold_cluster, 2):
            gold_pairs.add(tuple(sorted(pair)))

    predicted_pairs = set()
    for predicted_cluster in predicted_clustering:
        for pair in combinations(predicted_cluster, 2):
            predicted_pairs.add(tuple(sorted(pair)))

    overlapping_pairs = gold_pairs & predicted_pairs

    precision = 1. if len(predicted_pairs) == 0 else float(len(overlapping_pairs)) / len(predicted_pairs)
    recall = 1. if len(gold_pairs) == 0 else float(len(overlapping_pairs)) / len(gold_pairs)
    paired_f_score = 0. if precision + recall == 0 else 2 * precision * recall / (precision + recall)

    return paired_f_score


    #example call below
    #gold_clustering = [['comment', 'remark'], ['mark', 'observe', 'state'], ['tell', 'say', 'mention']]
    #predicted_clustering = [['comment', 'remark', 'mark'], ['observe', 'state'], ['tell', 'say', 'mention']]
    #f_score = get_paired_f_score(gold_clustering, predicted_clustering)
    #print(f_score)  # Output: 0.6

def evaluate_clusterings(gold_clusterings, predicted_clusterings):
    """
    Displays evaluation scores between gold and predicted clusterings
    :param gold_clusterings: dictionary where key is a target word and value is a list of list of paraphrases
    :param predicted_clusterings: dictionary where key is a target word and value is a list of list of paraphrases
    :return: N/A
    """
    target_words = set(gold_clusterings.keys()) & set(predicted_clusterings.keys())

    if len(target_words) == 0:
        print('No overlapping target words in ground-truth and predicted files')
        return None

    paired_f_scores = np.zeros((len(target_words)))
    ks = np.zeros((len(target_words)))

    table = PrettyTable(['Target', 'k', 'Paired F-Score'])
    for i, target_word in enumerate(target_words):
        paired_f_score = get_paired_f_score(gold_clusterings[target_word], predicted_clusterings[target_word])
        k = len(gold_clusterings[target_word])
        paired_f_scores[i] = paired_f_score
        ks[i] = k
        table.add_row([target_word, k, f'{paired_f_score:0.4f}'])

    average_f_score = np.average(paired_f_scores, weights=ks)
    print(table)
    print(f'=> Average Paired F-Score:  {average_f_score:.4f}')

    #example call below -> averages paired f score also weighted by no of senses that a target word has
    #gold_clusterings = {'note.v': [['comment', 'remark'], ['mark', 'observe', 'state'], ['tell', 'say', 'mention']]}
    #predicted_clusterings = {'note.v': [['comment', 'remark', 'mark'], ['observe', 'state'], ['tell', 'say', 'mention']]}
    #evaluate_clusterings(gold_clusterings, predicted_clusterings)

def write_to_output_file(file_path, clusterings):
    """
    Writes the result of clusterings into an output file
    :param file_path: path to an output file
    :param clusterings:  A dictionary, where key is a target word and value is a list of list of paraphrases
    :return: N/A
    """
    with open(file_path, 'w') as fout:
        for target_word, clustering in clusterings.items():
            for i, cluster in enumerate(clustering):
                fout.write(f'{target_word} :: {i + 1} :: {" ".join(cluster)}\n')
        fout.close()

"""## 3.1. Cluster Randomly [11 points]
Write a function `cluster_random(word_to_paraphrases_dict, word_to_k_dict)` that accepts 2 dictionaries:

1. word_to_paraphrases_dict = a mapping between a target word and a list of paraphrases

2. word_to_k_dict = a mapping between a target word and a number of clusters for a given target

The function outputs a dictionary, where the key is a target word and a value is a list of list of paraphrases, where a list of paraphrases represents a distinct sense of a target word.

For this task put paraphrases into distinct senses at random. That is, assign to pick a random word for each cluster, as opposed to picking a random cluster for each word. This will ensure that all clusters have at lease one word in them. We recommend using random packages. Please use 123 as a random seed. Your output should look similar to this on the development dataset:

```
word_to_paraphrases_dict, word_to_k_dict = load_input_file('dev_input.txt')
gold_clusterings = load_output_file('dev_output.txt')
predicted_clusterings = cluster_random(word_to_paraphrases_dict, word_to_k_dict)
evaluate_clusterings(gold_clusterings, predicted_clusterings)
```
```
+----------------+----+----------------+
|     Target     | k  | Paired F-Score |
+----------------+----+----------------+
|    paper.n     | 7  |     0.2978     |
|     play.v     | 34 |     0.0896     |
|     miss.v     | 8  |     0.2376     |
|   produce.v    | 7  |     0.2335     |
|    party.n     | 5  |     0.2480     |
|     note.v     | 3  |     0.6667     |
|     bank.n     | 9  |     0.1515     |
    .
    .
    .
|     eat.v      | 6  |     0.2908     |
|    climb.v     | 6  |     0.2427     |
|    degree.n    | 7  |     0.2891     |
|   interest.n   | 5  |     0.2093     |
+----------------+----+----------------+
=> Average Paired F-Score:  0.2318
```

- **Problem 3.1:** Implement `cluster_random` function. **The augograder for 3.2, 3.3, 3.4 will grade your implementation based on the test-set `f_score` achieved by the clustering.**  [10 points]

# Recitation


        word_to_paraphrases_dict = {
        'note.v': ['comment', 'mark', 'tell', 'observe', 'state', 'notice', 'say', 'remark', 'mention'],
        'hot.a': ['raging', 'spicy', 'blistering', 'red-hot', 'live']
                                    }

          word_to_k_dict = {
          'note.v': 3,
          'hot.a': 2
                           }

        Expected output :
        {
            'note.v': [['remark', 'mention'], ['comment', 'state', 'tell', 'mark'], ['observe', 'say', 'notice']],
            'hot.a': [['blistering', 'red-hot'], ['live', 'spicy', 'raging']]
        }

      shuffled = ['tell', 'remark', 'say', 'comment', 'mention', 'observe', 'state', 'mark', 'notice'] ->order reshuffled
"""

random.seed(123)

def cluster_random(word_to_paraphrases_dict, word_to_k_dict):
    """
    Clusters paraphrases randomly
    :param word_to_paraphrases_dict: dictionary, where key is a target word and value is a list of paraphrases
    :param word_to_k_dict: dictionary, where key is a target word and value is a number of clusters
    :return: dictionary, where key is a target word and value is a list of list of paraphrases,
    where each list corresponds to a cluster
    """
    clusterings = {}

    for target_word in word_to_paraphrases_dict.keys():
        paraphrase_list = word_to_paraphrases_dict[target_word]
        k = word_to_k_dict[target_word]
        # TODO: Implement
        clusters = []
        for i in range(k):
            clusters.append([])

        # Put paraphrases into clusters
        for i in range(len(paraphrase_list)):
            cluster_number = i % k
            clusters[cluster_number].append(paraphrase_list[i])

        # Store the clusters for this word in our results
        clusterings[target_word] = clusters

    return clusterings

"""- **Answer 3.1:** Run clustering on `dev` data, report the `f_scores` from the `dev` data [1 point]

**TODO**: [Report f_scores from the dev data]
"""

### Reference Code ###
###### You can use the following code to test your clustering on dev data ######
word_to_paraphrases_dict_dev, word_to_k_dict_dev = load_input_file('dev_input.txt')
predicted_clusterings_random_dev = cluster_random(word_to_paraphrases_dict_dev, word_to_k_dict_dev)
gold_clusterings_dev = load_output_file('dev_output.txt')
f_score = evaluate_clusterings(gold_clusterings_dev, predicted_clusterings_random_dev)
f_score

"""Run the following command to generate the output file for the predicted clusterings for the test dataset."""

word_to_paraphrases_dict, word_to_k_dict = load_input_file('test_input.txt')
predicted_clusterings_random = cluster_random(word_to_paraphrases_dict, word_to_k_dict)
write_to_output_file('test_output_random.txt', predicted_clusterings_random)

# PennGrader - DO NOT CHANGE
# reload_grader()
grader.grade(test_case_id = 'test_q3_clusters_random', answer = (predicted_clusterings_random, 'random'))

"""## 3.2 Cluster with Sparse Representations [26 points]

Write a function `cluster_with_sparse_representation(word_to_paraphrases_dict, word_to_k_dict)`. The input and output remains the same as in Task 1, however the clustering of paraphrases will no longer be random and is based on sparse vector representation.

We will feature-based (not dense) vector space representation. In this type of VSM, each dimension of the vector space corresponds to a specific feature, such as a context word (see, for example, the term-context matrix described in [Chapter 6.1.2 of Jurafsky & Martin](https://web.stanford.edu/~jurafsky/slp3/6.pdf)). You will calculate cooccurrence vectors on the Reuters RCV1 corpus. It can take a long time to build cooccurrence vectors, so we have pre-built set called `coocvec-500mostfreq-window-3.filter.magnitude`. To save on space, these include only the words used in the given files. This representation of words uses a term-context matrix `M` of size `|V| x D`, where `|V|` is the size of the vocabulary and D=500. Each feature corresponds to one of the top 500 most-frequent words in the corpus. The value of matrix entry `M[i][j]` gives the number of times the context word represented by column `j` appeared within W=3 words to the left or right of the word represented by row `i` in the corpus.

Use one of the clustering algorithms, for instance K-means clustering in `cluster_with_sparse_representation(word_to_paraphrases_dict, word_to_k_dict)`. Here is an example of the K-means clustering code:

# Recitation
This function is tasked with clustering paraphrases based on sparse vector representations.
We use concept of cooccurence matrix and sparse vector representations

1. Cooccurrence Vectors: Cooccurrence vectors represent how often each word in the vocabulary co-occurs with every other word in a given context window.
Suppose we have the following sentences in our corpus:

* "I like eating apples."
* "Apples are delicious."
* "She bought some apples from the market."
* "The teacher gave us apples as a snack."

Our vocabulary consists of the following words: "I", "like", "eating", "apples", "are", "delicious", "she", "bought", "some", "from", "the", "market", "teacher", "gave", "us", "as", "a", "snack".

The cooccurrence matrix would look something like this (simplified):

|        | I | like | eating | apples | are | delicious | she | bought | some | from | the | market | teacher | gave | us | as | a | snack |
|--------|---|------|--------|--------|-----|-----------|-----|--------|------|------|-----|--------|---------|------|----|----|---|-------|
| I      | 0 | 1    | 0      | 0      | 0   | 0         | 0   | 0      | 0    | 0    | 0   | 0      | 0       | 0    | 0  | 0  | 0 | 0     |
| like   | 1 | 0    | 1      | 0      | 0   | 0         | 0   | 0      | 0    | 0    | 0   | 0      | 0       | 0    | 0  | 0  | 0 | 0     |
| eating | 0 | 1    | 0      | 1      | 0   | 0         | 0   | 0      | 0    | 0    | 0   | 0      | 0       | 0    | 0  | 0  | 0 | 0     |
| apples | 0 | 0    | 1      | 0      | 1   | 1         | 1   | 1      | 1    | 1    | 1   | 1      | 0       | 0    | 0  | 0  | 0 | 0     |


The value at position (i, j) in the matrix represents the number of times word i co-occurs with word j within the context window.

This is an example of sparse vector representation because most of the matrix above is sparse. We are using sparse vector representation from Magnitude:

**coocvec-500mostfreq-window-3.filter.magnitude**: Derived from a co-occurrence matrix based on a corpus like Reuters RCV1.Each dimension represents the count of the word's co-occurrence with one of the top 500 most frequent context words within a window of 3 words.

```
from sklearn.cluster import KMeans
kmeans = KMeans(n_clusters=k).fit(X)
print(kmeans.labels_)
```

- **Problem 3.2:** Implement `cluster_with_sparse_representation` function [20 points]
"""

def cluster_with_sparse_representation(word_to_paraphrases_dict, word_to_k_dict):
    """
    Clusters paraphrases using sparse vector representation
    :param word_to_paraphrases_dict: dictionary, where key is a target word and value is a list of paraphrases
    :param word_to_k_dict: dictionary, where key is a target word and value is a number of clusters
    :return: dictionary, where key is a target word and value is a list of list of paraphrases,
    where each list corresponds to a cluster
    """

    vectors = Magnitude("coocvec-500mostfreq-window-3.filter.magnitude")
    clusterings = {}

    for target_word in word_to_paraphrases_dict.keys():
        paraphrase_list = word_to_paraphrases_dict[target_word]
        k = word_to_k_dict[target_word]

        paraphrase_vectors = []
        clusters =[]

        # When you query a word that is not in vectors, you will have this error. Please use np.random.rand(vectors.dim) to fill in, if the paraphrase is not in vectors

        for paraphrase in paraphrase_list:
            try:
                vector = vectors.query(paraphrase)
                paraphrase_vectors.append(vector)
            except:
                random_vector = np.random.rand(vectors.dim)
                paraphrase_vectors.append(random_vector)

        # Convert to numpy array for clustering
        paraphrase_vectors = np.array(paraphrase_vectors)

        #kmeans = KMeans(n_clusters=k).fit(X)
        kmeans = KMeans(n_clusters=k, random_state=123)
        cluster_labels = kmeans.fit_predict(paraphrase_vectors)

        # Group paraphrases by cluster
        # clusters = [[] for _ in range(k)]
        for i in range(k):
            clusters.append([])


        # Now we use paraphrase_list instead of valid_paraphrases since we keep all words
        for paraphrase, label in zip(paraphrase_list, cluster_labels):
            clusters[label].append(paraphrase)
            clusterings[target_word] = clusters


    return clusterings

"""# Recitation
Example:

        word_to_paraphrases_dict = {
        'note.v': ['comment', 'mark', 'tell', 'observe', 'state', 'notice', 'say', 'remark', 'mention'],
        'hot.a': ['raging', 'spicy', 'blistering', 'red-hot', 'live']
                                    }

          word_to_k_dict = {
          'note.v': 3,
          'hot.a': 2
                           }
        Expected output :
        {
            'note.v': [['remark', 'mention'], ['comment', 'state', 'tell', 'mark'], ['observe', 'say', 'notice']],
            'hot.a': [['blistering', 'red-hot'], ['live', 'spicy', 'raging']]
        }
          x (matrix of features):         Represent each word in 500 dimensions
          Word      dim1 dim2 dim3....dim500
          comment   ........................
          mark      ........................
          .
          .
          .
          mention   ,,,,,,,,,,,,,,,,,,,,,,,,
          if dimensions of the word not present in magnitude, randomly draw a vector from magnitude
        
        Once you have your X, run k means on that.
        #Kmeans must have assigned a cluster no to each of the 3 paraphrase
            #comment 0
            #tell 1
            #state 1
            #say 0

        Based on above (paraphrase,cluster no) pair, make your list of lists and hence your output dictionary

**Answer 3.2.1:** Run clustering on `dev` data, report the `f_scores` from the `dev` data [1 point]

**TODO**: [Report f_scores from the dev data]
"""

# YOUR CODE HERE (you can re-use reference code from 3.1)
word_to_paraphrases_dict_dev, word_to_k_dict_dev = load_input_file('dev_input.txt')
predicted_clusterings_random_dev = cluster_with_sparse_representation(word_to_paraphrases_dict_dev, word_to_k_dict_dev)
gold_clusterings_dev = load_output_file('dev_output.txt')
f_score = evaluate_clusterings(gold_clusterings_dev, predicted_clusterings_random_dev)
f_score

"""Run the following command to generate the output file for the predicted clusterings for the test dataset."""

word_to_paraphrases_dict, word_to_k_dict = load_input_file('test_input.txt')
predicted_clusterings_sparse = cluster_with_sparse_representation(word_to_paraphrases_dict, word_to_k_dict)
write_to_output_file('test_output_sparse.txt', predicted_clusterings_sparse)

# PennGrader - DO NOT CHANGE
# reload_grader()
grader.grade(test_case_id = 'test_q3_clusters_sparse', answer = (predicted_clusterings_sparse, 'sparse'))

"""**Answer 3.2.2:** Provide a brief description of your method in the report, making sure to describe the vector space model you chose, the clustering algorithm you used, and the results of any preliminary experiments you might have run on the dev set.  [5 points]

Suggestions to improve the performance of your model:

 - ~~What if you reduce or increase `D` in the baseline implementation?  **-> Increase or decrease Dimensions from 500, use such vector representation**~~

 - ~~Does it help to change the window `W` used to extract contexts? **-> The file coocvec-500mostfreq-window-3.filter.magnitude contains vectors that were generated with a window size W=3.This means that when the co-occurrence matrix was built, the context for each word was determined by considering up to 3 words to the left and 3 words to the right.Try changing that. use such vector representation**~~

 - Play around with the feature weighting – instead of raw counts, would it help to use PPMI? -**> Convert your co-occurrence matrix to a PPMI matrix and use these weighted vectors for clustering.**

 - Try a different clustering algorithm that’s included with the [scikit-learn clustering package](http://scikit-learn.org/stable/modules/clustering.html), or implement your own. **-> Agglomerative Clustering, DBSCAN**

 - What if you include additional types of features, like paraphrases in the [Paraphrase Database](http://www.paraphrase.org/) or the part-of-speech of context words? **-> Enrich your vectors with additional features and observe the impact on clustering performance.**

The only feature types that are off-limits are WordNet features.

Provide a brief description of your method in the Report, making sure to describe the vector space model you chose, the clustering algorithm you used, and the results of any preliminary experiments you might have run on the dev set.
"""

#This cluster uses Agglomerative Clustering
from sklearn.cluster import AgglomerativeClustering
def cluster_with_sparse_representation_AC(word_to_paraphrases_dict, word_to_k_dict):

    vectors = Magnitude("coocvec-500mostfreq-window-3.filter.magnitude")
    clusterings = {}

    for target_word in word_to_paraphrases_dict.keys():
        paraphrase_list = word_to_paraphrases_dict[target_word]
        k = word_to_k_dict[target_word]

        paraphrase_vectors = []
        clusters = []

        # When you query a word that is not in vectors, you will have this error. Please use np.random.rand(vectors.dim) to fill in, if the paraphrase is not in vectors
        for paraphrase in paraphrase_list:
            try:

                vector = vectors.query(paraphrase)
                paraphrase_vectors.append(vector)
            except:

                random_vector = np.random.rand(vectors.dim)
                paraphrase_vectors.append(random_vector)

        paraphrase_vectors = np.array(paraphrase_vectors)

        if len(paraphrase_list) > 0:
            # Perform agglomerative clustering
            AC = AgglomerativeClustering(
                n_clusters =k,
                metric='euclidean',
                linkage='single'
            )
            cluster_labels = AC.fit_predict(paraphrase_vectors)

            for i in range(k):
                clusters.append([])

            for paraphrase, label in zip(paraphrase_list, cluster_labels):
                clusters[label].append(paraphrase)

            clusterings[target_word] = clusters
        else:
            clusters = []
            for i in range(k):
                clusters.append([])
            clusterings[target_word] = clusters

    return clusterings

word_to_paraphrases_dict_dev, word_to_k_dict_dev = load_input_file('dev_input.txt')
predicted_clusterings_random_dev = cluster_with_sparse_representation_AC(word_to_paraphrases_dict_dev, word_to_k_dict_dev)
gold_clusterings_dev = load_output_file('dev_output.txt')
f_score = evaluate_clusterings(gold_clusterings_dev, predicted_clusterings_random_dev)
f_score

"""**TODO**: Description of your mothod

This method uses Agglomerative Clustering along with sparse vector representation. Sme params I used are euclidian distance and single linkage to minimize distances between clusters. At first I used cosine metric but it did not give an great f-score compared to euclidean.

## 3.3 Cluster with Dense Representations [28 points]

Write a function `cluster_with_dense_representation(word_to_paraphrases_dict, word_to_k_dict)`. The input and output remains the same as in Task 1 and 2, however the clustering of paraphrases is based on dense vector representation.

We would like to see if dense word embeddings are better for clustering the words in our test set. Run the word clustering task again, but this time use a dense word representation.

For this task, we have also included a file called `GoogleNews-vectors-negative300.filter.magnitude`, which is filtered to contain only the words in the dev/test splits.

As before, use the provided word vectors to represent words and perform one of the clusterings. Here are some suggestions to improve the performance of your model:

 - Try downloading a different dense vector space model from the web, like [Paragram](http://www.cs.cmu.edu/~jwieting/) or [fastText](https://fasttext.cc/docs/en/english-vectors.html).
 - Train your own word vectors, either on the provided corpus or something you find online. You can try the skip-gram, CBOW models, or [GLOVE](https://nlp.stanford.edu/projects/glove/). Try experimenting with the dimensionality.
 - [Retrofitting](https://www.cs.cmu.edu/~hovy/papers/15HLT-retrofitting-word-vectors.pdf) is a simple way to add additional semantic knowledge to pre-trained vectors. The retrofitting code is available here. Experiment with different lexicons, or even try [counter-fitting](http://www.aclweb.org/anthology/N16-1018).

- **Problem 3.3:** Implement `cluster_with_dense_representation` function [20 points]

# Recitation
**GoogleNews-vectors-negative300.magnitude:**



*   Dense vector representation.
*   Trained on a large corpus of Google News articles.
*   300 dimensions

300 dimensions
"""

def cluster_with_dense_representation(word_to_paraphrases_dict, word_to_k_dict):
    """
    Clusters paraphrases using dense vector representation
    :param word_to_paraphrases_dict: dictionary, where key is a target word and value is a list of paraphrases
    :param word_to_k_dict: dictionary, where key is a target word and value is a number of clusters
    :return: dictionary, where key is a target word and value is a list of list of paraphrases,
    where each list corresponds to a cluster
    """

    vectors = Magnitude("GoogleNews-vectors-negative300.magnitude")
    clusterings = {}

    for target_word in word_to_paraphrases_dict.keys():
        paraphrase_list = word_to_paraphrases_dict[target_word]
        k = word_to_k_dict[target_word]

        paraphrase_vectors = []

        for paraphrase in paraphrase_list:
            try:
                vector = vectors.query(paraphrase)
                paraphrase_vectors.append(vector)
            except:
                random_vector = np.random.rand(vectors.dim)
                paraphrase_vectors.append(random_vector)
        paraphrase_vectors = np.array(paraphrase_vectors)

        if len(paraphrase_list) > 0:

            # ac = AgglomerativeClustering(
            #     n_clusters=k,
            #     metric='cosine',     # Using cosine distance for word vectors
            #     linkage='single'     # Using single linkage
            # )
            # cluster_labels = ac.fit_predict(paraphrase_vectors)
            kmeans = KMeans(
                n_clusters=k,
                random_state=123,
                n_init=20
            )
            cluster_labels = kmeans.fit_predict(paraphrase_vectors)

            clusters = []
            for i in range(k):
                clusters.append([])

            for paraphrase, label in zip(paraphrase_list, cluster_labels):
                clusters[label].append(paraphrase)

            clusterings[target_word] = clusters
        else:
            clusters = []
            for i in range(k):
                clusters.append([])
            clusterings[target_word] = clusters

    return clusterings

"""**Answer 3.3.1:** Run clustering on `dev` data, report the `f_scores` from the `dev` data [1 point]

**TODO**: [Report f_scores from the dev data]
"""

# YOUR CODE HERE (you can re-use reference code from 3.1)
word_to_paraphrases_dict_dev, word_to_k_dict_dev = load_input_file('dev_input.txt')
predicted_clusterings_random_dev = cluster_with_dense_representation(word_to_paraphrases_dict_dev, word_to_k_dict_dev)
gold_clusterings_dev = load_output_file('dev_output.txt')
f_score = evaluate_clusterings(gold_clusterings_dev, predicted_clusterings_random_dev)
f_score



"""As before, run the following command to generate the output file for the predicted clusterings for the test dataset."""

word_to_paraphrases_dict, word_to_k_dict = load_input_file('test_input.txt')
predicted_clusterings_dense = cluster_with_dense_representation(word_to_paraphrases_dict, word_to_k_dict)
write_to_output_file('test_output_dense.txt', predicted_clusterings_dense)

# PennGrader - DO NOT CHANGE
# reload_grader()
grader.grade(test_case_id = 'test_q3_clusters_dense', answer = (predicted_clusterings_dense, 'dense'))

"""**Answer 3.3.2:** Provide a brief description of your method in the report that includes the vectors you used, and any experimental results you have from running your model on the dev set.  [5 points]

**TODO**: [Describe your method]

**Answer 3.3.3:** In addition, for Task 3.2 and 3.3, do an analysis of different errors made by each system – i.e. look at instances that the word-context matrix representation gets wrong and dense gets right, and vice versa, and see if there are any interesting patterns. There is no right answer for this. [2 points]

# Recitation
To compare, make a dataframe
**Target word | F score_ sparse | F score_dense | Diff sparse - dense | Diff dense - sparse**

Now sort based on diff_sparse and diff_dense to identify words where one works better than other

**TODO**: [Error analysis]

## 3.4 Cluster without K [31 points]

So far we made the clustering problem deliberately easier by providing you with `k`, the number of clusters, as an input. But in most clustering situations the best `k` is not given. To take this assignment one step further, see if you can come up with a way to automatically choose `k`.

Write a function `cluster_with_no_k(word_to_paraphrases_dict)` that accepts only the first dictionary as an input and produces clusterings for given target words.

We have provided an additional test set `test_nok_input.txt`, where the `k` field has been zeroed out. See if you can come up with a method that clusters words by sense, and chooses the best `k` on its own. You can start by assigning `k=5` for all target words as a baseline model.

You might want to try and use the development data to analyze how got is your model in determining `k`.

One of the ways to approach this challenge is to try and select best `k` for a target word and a list of paraphrases is to use try out a range of `k`'s and judge the performance of the clusterings based on some metric, for instance a [silhouette score](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.silhouette_score.html).

Be sure to describe your method in the Report.

- **Problem 3.4:** Implement `cluster_with_no_k` function [25 points]

# Recitation
**Till now we had been giving K and you used that in K means to split your paraphrase list into list of lists (clusters). Now in this section we dont give you K. For this, Keep logic similar where you were preparing matrix of features. Next step : Try K means using diff number of clusters. Calculate silhouette score for each number and finally chose the optimal no of clusters for that target word**
"""

from sklearn.metrics import silhouette_score # Hint: this could be useful if you want to use silhouette_score as distance metric

def cluster_with_no_k(word_to_paraphrases_dict):
    """
    Clusters paraphrases using any vector representation
    :param word_to_paraphrases_dict: dictionary, where key is a target word and value is a list of paraphrases
    :return: dictionary, where key is a target word and value is a list of list of paraphrases,
    where each list corresponds to a cluster
    """
    from sklearn.cluster import KMeans
    from sklearn.metrics import silhouette_score
    import numpy as np

    vectors = Magnitude("GoogleNews-vectors-negative300.magnitude")
    clusterings = {}

    for target_word in word_to_paraphrases_dict.keys():
        paraphrase_list = word_to_paraphrases_dict[target_word]
        paraphrase_vectors = []
        valid_paraphrases = []

        for paraphrase in paraphrase_list:
            try:
                vector = vectors.query(paraphrase)
                paraphrase_vectors.append(vector)
                valid_paraphrases.append(paraphrase)
            except:
                random_vector = np.random.rand(vectors.dim)
                paraphrase_vectors.append(random_vector)
                valid_paraphrases.append(paraphrase)

        paraphrase_vectors = np.array(paraphrase_vectors)

        if len(valid_paraphrases) > 0:
            n_samples = len(valid_paraphrases)
            max_k = min(10, n_samples - 1)

            if n_samples < 2:
                optimal_k = 1
            else:
                min_k = 2
                max_k_for_silhouette = min(max_k, n_samples - 1)

                if max_k_for_silhouette < min_k:
                    optimal_k = 1
                else:
                    silhouette_scores = []
                    k_values = range(min_k, max_k_for_silhouette + 1)
                    #debug this later
                    for k in k_values:
                        try:
                            kmeans = KMeans(n_clusters=k, random_state=123, n_init=15)
                            cluster_labels = kmeans.fit_predict(paraphrase_vectors)
                            score = silhouette_score(paraphrase_vectors, cluster_labels)
                            silhouette_scores.append(score)
                            # print(f"For k={k}, silhouette score: {score}")

                        except:
                            silhouette_scores.append(-1)


                    if len(silhouette_scores) > 0 and max(silhouette_scores) > 0:
                        optimal_k = k_values[np.argmax(silhouette_scores)]
                    else:
                        optimal_k = min(5, max(1, n_samples // 2))

            kmeans = KMeans(n_clusters=optimal_k, random_state=42, n_init=10)
            cluster_labels = kmeans.fit_predict(paraphrase_vectors)

            clusters = []
            for i in range(optimal_k):
                clusters.append([])

            for paraphrase, label in zip(valid_paraphrases, cluster_labels):
                clusters[label].append(paraphrase)

            clusters = [cluster for cluster in clusters if len(cluster) > 0]
            clusterings[target_word] = clusters
        else:
            clusterings[target_word] = [[]]

    return clusterings

"""**Answer 3.4.1:** Run clustering on `dev` data, report the `f_scores` from the `dev` data [1 point]

**TODO:** [Report f_score on dev data]
"""



# YOUR CODE HERE (you can re-use reference code from 3.1)
word_to_paraphrases_dict_dev, word_to_k_dict_dev = load_input_file('dev_input.txt')
predicted_clusterings_random_dev = cluster_with_no_k(word_to_paraphrases_dict_dev)
gold_clusterings_dev = load_output_file('dev_output.txt')
f_score = evaluate_clusterings(gold_clusterings_dev, predicted_clusterings_random_dev)
f_score

"""As before, run the following command to generate the output file for the predicted clusterings for the test dataset."""

word_to_paraphrases_dict, _ = load_input_file('/content/test_nok_input.txt')
predicted_clusterings_nok = cluster_with_no_k(word_to_paraphrases_dict)
write_to_output_file('test_output_nok.txt', predicted_clusterings_nok)

# PennGrader - DO NOT CHANGE
# reload_grader()
grader.grade(test_case_id = 'test_q3_clusters_no_k', answer = (predicted_clusterings_nok, 'no k'))

"""**Answer 3.4.2:** Provide a brief description of your method in the report that includes the vectors you used, and any experimental results you have from running your model on the dev set.  [5 points]

**TODO**: [Describe your method]

# Submissions

## Leaderboards [2 points + 3 bonus]
In order to stir up some friendly competition, we would also like you to submit the clustering from your best model to a leaderboard. There will be 2 leaderboards to submit to:
- **Clusters with no K**: Copy the output file from your best model **(has to come from `3.4`)** to a file called `test_nok_output_leaderboard.txt` and include it with your submission in `HW5: Leaderboard Without K` following the format of the clusters file. [1 point]

- **Clusters with K**: Copy the output file from your best model **(has to come from `3.2 or 3.3`)** to a file called `test_output_leaderboard.txt` and include it with your submission in `HW5: Leaderboard With K` following the format of the clusters file. [1 point]

The first 10 places in either of the two leaderboards get 3 extra points.

## Free-response Checklist (check if you missed anything!)
We will look for the following free-responses in this notebook:
- Section 2: Question responses and analysis of correlations
- Section 3: For each clustering algorithm, you would need to report the `f_score` from the `dev` set and description of your methods.

## GradeScope File Submission
Here are the deliverables you need to submit to GradeScope:
- Write-up:
    - Part 2: answers to questions
    - Part 3: F-scores for clustering algorithms & discussions about your models
- Code:
    - This notebook and py file: rename to `homework5.ipynb` and `homework5.py`. You can download the notebook and py file by going to the top-left corner of this webpage, `File -> Download -> Download .ipynb/.py`
- Leaderboard Results:
  - Leaderboard Without K: `test_nok_output_leaderboard.txt` (Task 3.4 output file)
  - Leaderboard With K: `test_output_leaderboard.txt` (Task 3.2 or 3.3 output file)
"""

word_to_paraphrases_dict, _ = load_input_file('/content/test_nok_input.txt')
predicted_clusterings_nok = cluster_with_no_k(word_to_paraphrases_dict)
write_to_output_file('test_nok_output_leaderboard.txt', predicted_clusterings_nok)

word_to_paraphrases_dict, word_to_k_dict = load_input_file('test_input.txt')
predicted_clusterings_dense = cluster_with_dense_representation(word_to_paraphrases_dict, word_to_k_dict)
write_to_output_file('test_output_leaderboard.txt', predicted_clusterings_dense)

